---
layout:     post
title:      "kubevirt以容器方式运行虚拟机"
subtitle:   ""
date:       2018-09-14
author:     "min"
header-img: "img/post-bg-2015.jpg"
tags:
    - k8s
    - container
    - kubevirt
---

# kubevirt以容器方式运行虚拟机

* [什么是kubevirt](#什么是kubevirt)
* [kubevirt架构](#kubevirt架构)
    * [kubevirt工作流程](#kubevirt工作流程)
* [kubevirt存储](#kubevirt存储)
* [虚拟机网络](#虚拟机网络)
* [kubevirt安装](#kubevirt安装)



## 什么是kubevirt

随着k8s生态的加持越来越凸显了容器优势，部署快捷运维方便。kubevirt项目提供了可以利用k8s平台
实现虚拟机管理服务。kubevirt是Redhat开源的以容器方式运行虚拟机的项目，通过Kubernetes CRD相关功能实现以容器方式调度管理
虚拟机。 


## kubevirt架构

Kubevirt是以k8s add-on方式，利用k8s CRD为增加资源类型`VirtualMachineInstance（VMI）`，提供VM生命周期管理。
kubevirt目前支持的runtime是docker和runv，本文中使用的docker。
Kubevirt架构如图所示，由4部分组件组成。

![](/img/2018-09-14-kubevirt/architecture.png)

- virt-api
    
    kubevirt API服务，kubevirt是以CRD的方式工作的，virt-api提供了自定义的api请求处理，如`vnc` `console`
    `start vm` `stop vm`等

- virt-controller
    
    * 与k8s api-server通讯监控`VMI`资源创建删除等状态
    * 根据`VMI`定义创建`virt-launcher`pod，pod中将会运行虚拟机
    * 监控pod状态，并随之更新`VMI`状态
    * 监控标记为"kubevirt.io/schedulable" node heartbeat

- virt-handler
    
    * 运行在kubelet的node上定期更新heartbeat，并标记"kubevirt.io/schedulable"
    * 监听在k8s apiserver当发现`VMI`被标记得nodeName与自身node匹配时，负责虚拟机的生命周期管理
    
- virt-launcher
    * 以pod形式运行
    * 根据`VMI`定义生成虚拟机模板，通过libvirt API创建虚拟机
    * 即每个虚拟机会对应对立的libvirtd
    * 与libvirt通讯提供虚拟机生命周期管理


### kubevirt工作流程

1. client 发送创建VMI命令达到k8s API server.
2. K8S API 创建创建VMI
3. virt-controller监听到VMI创建时，根据VMI spec生成pod spec文件，创建pods
4. k8s创建pods
5. virt-controller监听到pods创建后，根据pods的调度node，更新VMI 的nodeName
6. virt-handler监听到VMI nodeName与自身节点匹配后，通知virt-launcher创建虚拟机，并负责虚拟机生命周期管理

```commandline
Client                     K8s API     VMI CRD  Virt Controller         VMI Handler
-------------------------- ----------- ------- ----------------------- ----------

                           listen <----------- WATCH /virtualmachines
                           listen <----------------------------------- WATCH /virtualmachines
                                                  |                       |
POST /virtualmachines ---> validate               |                       |
                           create ---> VMI ---> observe --------------> observe
                             |          |         v                       v
                           validate <--------- POST /pods              defineVMI
                           create       |         |                       |
                             |          |         |                       |
                           schedPod ---------> observe                    |
                             |          |         v                       |
                           validate <--------- PUT /virtualmachines       |
                           update ---> VMI ---------------------------> observe
                             |          |         |                    launchVMI
                             |          |         |                       |
                             :          :         :                       :
                             |          |         |                       |
DELETE /virtualmachines -> validate     |         |                       |
                           delete ----> * ---------------------------> observe
                             |                    |                    shutdownVMI
                             |                    |                       |
                             :                    :                       :
```

## kubevirt存储

虚拟机的磁盘kubevirt目前提供了多种方式的

- registryDisk
    
    virt-controller会在pod定义中创建registryVolume的container，container中的entry服务负责
    将spec.volumes.registryDisk.image 转化为qcow2格式作为disk。
    一般是用在root disk，类似与nova-compute 从glance下载image创建root disk的过程

- cloudInitNoCloud
    
    对虚拟机利用cloudinit做初始化，类似与nova中的configdrive，会根据spec.volumes.cloudInitNoCloud
    创建包含iso文件，包含 meta-data 和 user-data。

- emptyDisk
    
    创建空的qcow2 image挂载给虚拟机

- PVC

    上述几种disk都是非持久化的，随之pod的生命周期消亡，PVC是k8s提供的持久化存储。PVC被`VMI`使用是由要求的，
    PVC其实是mount在POD中，而虚拟机的file方式的虚拟化磁盘是具体的文件并不是目录，代码里写死的是mount的目录下必需
    由一个名称为`disk.img`的文件，才能去挂载PVC
    
- dataVolume
    
    dataVolume是kubevirt下的一个子项目containerized-data-importer(CDI)，
    也是以CDR的方式增加`DataVolume`resource。
    可以看成是从PVC和registryDisk衍生出来的，上面提过PVC使用是比较麻烦的，不仅需要PVC还需要创建disk.img，
    dataVolume其实将这个过程简化了，类似registryDisk，自动化的将disk.img创建在PVC中。
    创建DataVolume是可以定义`source`即image/data来源可以是`http`或者`s3`的URL，CDI controller会将
    自动将image转化并拷贝到PVC文件系统`/disk.img`

## 虚拟机网络

kubevirt虚拟机网络使用的是pod网络也就是说，虚拟网络原生与pod之间是打通的。虚拟机具体的网络如图所示，
virt-launcher pod网络的网卡不再挂有pod ip，而是作为虚拟机的虚拟网卡的与外部网络通信的交接物理网卡。
那么虚拟机是如何拿到pod的ip的呢，`virt-launcher`实现了简单的单ip dhcp server，就是需要虚拟机中
启动dhclient，virt-launcher服务会分配给虚拟机。

![](/img/2018-09-14-kubevirt/vm-networking.png)

使用命令`kubectl exec  $virt-launch-pod -c compute -- brctl show`可以看到bridge信息。
其中eth0就是pod与host网络通讯的veth peer网卡。也可以通过`virsh dumpxml`命令查看虚拟机的xml定义文件。

### 网络磁盘设备挂载

熟悉openstack的朋友应该也了解nova-compute中如何使用ceph rbd image的，实质上是libvirt使用librbd以`network`方式
将rbd image远程改在给虚拟机。而kubevirt中将POD ip移交给了虚拟机，那将意味着pod内的libvirt服务其实是无法直接使用`network` disk的。
要么增加网络代理转发即通过host来与网络设备通讯，要么就是采用k8s volumeMount:block feature来实现。
kubevirt社区有[PR](https://github.com/kubevirt/kubevirt/pull/899)已经实现了以Block的方式去使用是rbd image，笔者手动merge并测试通过。
实质是使用了kernel rbd.ko，首先将rbd image map到host，block的mount方式
将不再以文件系统方式去挂载/dev/rbdx，而是为作为原始设备给pod，而pod内的libvirt就可以`block`方式将rbd image作为
磁盘挂载给虚拟机。

相较于PVC先格式化为文件系统并必须创建disk.img文件的使用方式，显然rbd image 以block device直接作为块设备给虚拟机少了本地文件系统层
单从存储效率讲都能提高不少。至于`librbd`和`rbd.ko`的性能本文没有对比测试，只有有时间再补充。


# kubevirt 安装

首先需要k8s环境，本文中使用的是`v1.10.5`版本，kubevirt选择`v0.8.0`，调用如下命令部署kubevirt

```commandline
$ export VERSION=v0.8.0
$ kubectl create \
    -f https://github.com/kubevirt/kubevirt/releases/download/$VERSION/kubevirt.yaml
```

kubevirt.yaml中定义了RBAC相关认证，默认管理服务都创建再`kube-system` namespace中，可以通过以下命令查看
资源，已经服务部署状态。当看到pods全部创建成功后，通过`kubectl get vmis`来检测服务是否可用。

```commandline
 kubectl get all -n kube-system -l kubevirt.io
NAME                                   READY     STATUS    RESTARTS   AGE
pod/virt-api-54cc86ff87-9xt8s          1/1       Running   0          14d
pod/virt-api-54cc86ff87-xvjg4          1/1       Running   0          14d
pod/virt-controller-769db5f6bf-2wgr4   1/1       Running   0          13d
pod/virt-controller-769db5f6bf-xwgks   1/1       Running   0          13d
pod/virt-handler-gpn6b                 1/1       Running   0          2h

NAME               TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE
service/virt-api   ClusterIP   172.30.7.81   <none>        443/TCP   16d

NAME                          DESIRED   CURRENT   READY     UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE
daemonset.apps/virt-handler   1         1         1         1            1           <none>          16d

NAME                              DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/virt-api          2         2         2            2           16d
deployment.apps/virt-controller   2         2         2            2           16d

NAME                                         DESIRED   CURRENT   READY     AGE
replicaset.apps/virt-api-54cc86ff87          2         2         2         14d
replicaset.apps/virt-api-645f74c7fc          0         0         0         16d
replicaset.apps/virt-controller-658bf69f57   0         0         0         16d
replicaset.apps/virt-controller-769db5f6bf   2         2         2         14d

```
## 创建一个`vmi`

可以从github.com/kubevirt/kubevirt 项目中，cluster/examples下的yaml文件去创建虚拟机，创建完成后可以
使用ssh登陆查看虚拟机或者使用`virtctl console `和 `virtctl vnc`来登陆虚拟机。
```commandline
# kubectl create -f vmi-flavor-small.yaml
# kubectl get vmis
NAME               AGE
vmi-flavor-small   15h
vmi_pvc-windows        14h
# kubectl get pods 
virt-launcher-vmi-flavor-small-7m2cj   2/2       Running             0          2h
virt-launcher-vmi-pvc-windows-wvg5c   1/1       Running             0          14d
```

### kubevirt on openshift

Kubevirt在openshift部署是类似的，唯一不同的是需要为kubevirt service account增加openshift权限
在需要使用block volumemount时，openshift需要修改origin-node的配置文件增加feature-gates "BlockVolume=true"

```commandline
oc adm policy add-scc-to-user privileged system:serviceaccount:kube-system:kubevirt-privileged

oc adm policy add-scc-to-user privileged system:serviceaccount:kube-system:kubevirt-controller

oc adm policy add-scc-to-user privileged system:serviceaccount:kube-system:kubevirt-infra

oc adm policy add-scc-to-user privileged system:serviceaccount:kube-system:kubevirt-apiserver

```


## 其他
Redhat开源的kubevirt和Mirantis开源的`virtlet`实现以容器方式运行虚拟机，
至于两者之间的区别，可以看下这篇Mirantis的
[blog](https://www.mirantis.com/blog/kubevirt-vs-virtlet-comparison-better/)。

从资源调度的角度看virtlet项目可以实现利用k8s controller manager强大的调度管理功能，但是
virtlet项目又引进了cri-proxy作为中间服务层，处理路径增长，即cri-proxy服务故障将会导致
所有node失效，而virtlet目前采用的是每个node启动一个libvirtd服务，那么libvirtd服务的故障
也会引起发虚拟机无法管理创建。kubevirt每个virt-laucher pod中都有独立的libvirt服务则不存在这个
问题，libvirt服务的升级也变得相对容易因为不同的实例是隔离的。